server_tokens off;

# A value of the "Connection" header field in a request to the proxied server
# depends on the presence of the "Upgrade" field in the client request header
# More here: http://nginx.org/en/docs/http/websocket.html
map $http_upgrade $connection_upgrade {
  default upgrade;
  '' close;
}

server {
  listen 8080 default_server;
  server_name nginx;
  resolver %RESOLVER_ADDR%;

  set_by_lua_block $ws_server_base_url {
    return os.getenv("WS_SERVER_BASE_URL")
  }
  set_by_lua_block $authorization_url {
    return os.getenv("API_AUTH_BASE_URL") .. os.getenv("API_AUTH_PATH")
  }
  set_by_lua_block $allowed_origin {
    return os.getenv("ACCESS_CONTROL_ALLOW_ORIGIN")
  }
  set_by_lua_block $swagger_access_allow {
    return os.getenv("ALLOW_SWAGGER_ACCESS")
  }

  location /api-docs/ {
    alias /komgo/swagger-ui/;
    if ($swagger_access_allow != "true"){
      error_page 404 /404.html;
      return 404;
    }
    index index.html;
  }

  location /socket.io/ {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_set_header X-NginX-Proxy true;

    proxy_pass $ws_server_base_url;
    proxy_redirect off;

    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
  }

  # internal location handler that passes JWT token to authorization endpoint
  # and returns an authorization info;
  location = /authorize {
    internal;
    proxy_pass $authorization_url$is_args$args;
    proxy_pass_request_body off;
    proxy_set_header Host $http_host;
    proxy_set_header Content-Length "";
    proxy_set_header X-Request-ID $custom_request_id;
    add_header X-Request-ID $custom_request_id always;
  }
  location / {
    error_page 404 /404.html;
    root /usr/local/openresty/nginx/html/;
    return 404;
  }
  location /404.html {
    error_page 404 /404.html;
    root /usr/local/openresty/nginx/html/;
    internal;
  }

  # API gateway
  location ~ ^/api/([^/]+)/(.*)$ {

    # Enable CORS
    add_header 'Access-Control-Allow-Origin' "$allowed_origin" always;
    add_header 'Access-Control-Allow-Credentials' 'true' always;
    add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, PATCH, DELETE, OPTIONS' always;
    # Custom headers and headers various browsers *should* be OK with but aren't
    add_header 'Access-Control-Allow-Headers' 'Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Requested-With' always;
    add_header 'Access-Control-Expose-Headers' 'X-Request-ID' always;

    if ($request_method = 'OPTIONS') {
      # duplicated add_header's are necessary due to how nginx processes them
      add_header 'Access-Control-Allow-Origin' "$allowed_origin" always;
      add_header 'Access-Control-Allow-Credentials' 'true' always;
      add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, PATCH, DELETE, OPTIONS' always;
      # Custom headers and headers various browsers *should* be OK with but aren't
      add_header 'Access-Control-Allow-Headers' 'Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Requested-With' always;

      # Tell client that this pre-flight info is valid for 20 days
      add_header 'Access-Control-Max-Age' 1728000;
      add_header 'Content-Type' 'text/plain; charset=utf-8';
      add_header 'Content-Length' 0;
      return 204;
    }

    set $tenant_static_id '';
    set $custom_request_id $msec$request_id;
    set $target_base_url '';  # will be overwritten later in the Lua script (e.g. http://api-users)
    set $target_path /$2;  # e.g. /v0/profile
    set $target_path_and_query $target_path$is_args$args;  # e.g. /v0/profile?param1=abc
    set $service_name $1;  # users, roles, etc.

    # check authorization and if OK, forward the request to a target microservice
    access_by_lua_block {
      local service_name_to_url = {
        ["users"] = os.getenv("API_USERS_BASE_URL"),
        ["roles"] = os.getenv("API_ROLES_BASE_URL"),
        ["notif"] = os.getenv("API_NOTIF_BASE_URL"),
        ["docs"] = os.getenv("API_DOCUMENTS_BASE_URL"),
        ["registry"] = os.getenv("API_REGISTRY_BASE_URL"),
        ["trade-cargo"] = os.getenv("API_TRADE_CARGO_BASE_URL"),
        ["trade-finance"] = os.getenv("API_TRADE_FINANCE_BASE_URL"),
        ["coverage"] = os.getenv("API_COVERAGE_BASE_URL"),
        ["signer"] = os.getenv("API_SIGNER_BASE_URL"),
        ["blockchain-signer"] = os.getenv("API_BLOCKCHAIN_SIGNER_BASE_URL"),
        ["receivable-finance"] = os.getenv("API_RECEIVABLE_FINANCE_BASE_URL"),
        ["magic-link"] = os.getenv("API_MAGIC_LINK_BASE_URL"),
        ["products"] = os.getenv("API_PRODUCTS_BASE_URL"),
        ["timer"] = os.getenv("API_TIMER_BASE_URL"),
        ["credit-lines"] = os.getenv("API_CREDIT_LINES_BASE_URL"),
        ["onboarding"] = os.getenv("API_ONBOARDING_BASE_URL"),
        ["template"] = os.getenv("API_TEMPLATE_BASE_URL")
      }

      if service_name_to_url[ngx.var.service_name] == nil then
        ngx.header.content_type = "plain/text"
        ngx.status = 404
        ngx.print("Service '" .. ngx.var.service_name .. "' not found")
        -- return 404 if a requested service doesn"t exist
        ngx.exit(ngx.OK)
      end

      ngx.var.target_base_url = service_name_to_url[ngx.var.service_name]

      if os.getenv("ENABLE_UNAUTHORIZED_ACCESS") == "true" and ngx.req.get_headers()["X-Skip-Auth"] == "true" then
        -- skip authorization step
        return
      end

      -- pass additional query string args to the Auth service
      local res = ngx.location.capture("/authorize", { args = { baseUrl = ngx.var.target_base_url,
                                                                method = ngx.var.request_method,
                                                                path = ngx.var.target_path },
                                                       vars = { custom_request_id = ngx.var.custom_request_id } })
      -- Auth service must return HTTP 204 (No content) if everything is OK
      if res.status ~= ngx.HTTP_NO_CONTENT then
        -- Authorization failed. Return response from Auth to client
        ngx.header.content_type = res.header['Content-Type']
        ngx.status = res.status
        ngx.print(res.body)

        ngx.exit(ngx.OK)
      end

      ngx.var.tenant_static_id = res.header['X-Tenant-StaticID']
    }

    proxy_set_header Host $http_host;
    proxy_set_header X-Request-ID $custom_request_id;
    proxy_set_header X-Tenant-StaticID $tenant_static_id;
    proxy_pass $target_base_url$target_path_and_query;
    add_header X-Request-ID $custom_request_id always;
  }

}
