import { ErrorCode } from '@komgo/error-utilities'
import logger, { getLogger } from '@komgo/logging'
import { IRFPMessage, IRFPResponsePayload } from '@komgo/messaging-types'
import { tradeFinanceManager } from '@komgo/permissions'
import { ReplyType } from '@komgo/types'
import { inject, injectable } from 'inversify'
import { v4 as uuid4 } from 'uuid'

import { REDACTED_CONTENT } from '../../../constants'
import { RFPDataAgent, ReplyDataAgent } from '../../../data-layer/data-agents'
import { IReply } from '../../../data-layer/models/replies/IReply'
import { ErrorName } from '../../../ErrorName'
import { TYPES } from '../../../inversify/types'
import { VALUES } from '../../../inversify/values'
import { InvalidPayloadProcessingError, ValidationDuplicateError, ValidationFieldError } from '../../errors'
import { NotificationClient, CompanyRegistryClient } from '../../microservice-clients'
import { IProductResponse } from '../../types'
import { RFPValidator } from '../../validation'

import { IReceiveMessageUseCase } from './IReceiveMessageUseCase'

const RD_QUOTE_DECLINED = 'Receivable discounting quote declined'
const RD_REQUEST = 'Receivable discounting request'

@injectable()
export class ReceiveDeclineMessageUseCase implements IReceiveMessageUseCase {
  private readonly logger = getLogger('ReceiveDeclineMessageUseCase')

  constructor(
    @inject(TYPES.ReplyDataAgent) private readonly replyDataAgent: ReplyDataAgent,
    @inject(TYPES.RFPDataAgent) private readonly rfpDataAgent: RFPDataAgent,
    @inject(TYPES.RFPValidator) private readonly rfpValidator: RFPValidator,
    @inject(VALUES.CompanyStaticId) private readonly companyStaticId: string,
    @inject(TYPES.NotificationClient) private readonly notificationClient: NotificationClient,
    @inject(TYPES.CompanyRegistryClient) private readonly companyRegistryClient: CompanyRegistryClient
  ) {}
  /**
   * @throws InvalidPayloadProcessingError if the payload is invalid and can't be processed
   */
  public async execute(message: IRFPMessage<IRFPResponsePayload<IProductResponse>>) {
    const productResponse: IProductResponse = message.data.response
    this.logger.info('Processing received Response message', {
      message: { ...message, data: REDACTED_CONTENT }
    })

    let rfpReply: IReply
    if (productResponse) {
      rfpReply = productResponse.rfpReply
    } else {
      logger.info('Auto-decline message found, auto-generating the auto-decline RFP reply')
      rfpReply = await this.generateRFPReply(message.data)
    }

    logger.info('Validating RFP reply')
    await this.rfpValidator.validateRFPReplyNotProcessed(rfpReply)
    await this.validateRFPReply(rfpReply)

    await this.replyDataAgent.updateCreate(rfpReply)

    this.logger.info('Successfully processed quote decline message', {
      rdId: rfpReply.rdId
    })

    await this.sendNotification(message.context, message.data.senderStaticID, rfpReply.rdId)
  }

  private async generateRFPReply(data: IRFPResponsePayload<IProductResponse>): Promise<IReply> {
    const rfp = await this.rfpDataAgent.findByRfpId(data.rfpId)
    if (!rfp) {
      this.logger.error(ErrorCode.ValidationInternalAMQP, ErrorName.RFPDeclineRFPNotFound, {
        rfpId: data.rfpId
      })
      throw new InvalidPayloadProcessingError('Associated RFP could not be found')
    }
    return {
      staticId: uuid4(),
      type: ReplyType.Declined,
      rdId: rfp.rdId,
      participantId: this.companyStaticId,
      senderStaticId: data.senderStaticID,
      autoGenerated: true
    }
  }

  private async validateRFPReply(rfpReply: IReply) {
    try {
      await this.rfpValidator.validateInboundQuoteDecline(rfpReply)
    } catch (error) {
      if (error instanceof ValidationDuplicateError || error instanceof ValidationFieldError) {
        this.logger.error(ErrorCode.ValidationInternalAMQP, ErrorName.RFPDeclineCannotBeProcessed, {
          rfpReply
        })
        throw new InvalidPayloadProcessingError('RD Decline message cannot be processed by member')
      }
      throw error
    }
  }

  private async sendNotification(context: any, senderStaticId: string, rdId: string) {
    const senderCompanyName = await this.companyRegistryClient.getCompanyNameFromStaticId(senderStaticId)

    const hasResponse = await this.hasResponseBeenSent(rdId)

    const notifMsg = hasResponse
      ? `${RD_QUOTE_DECLINED} by ${senderCompanyName}`
      : `${RD_REQUEST} from ${senderCompanyName} expired`

    const emailNotifMsg = hasResponse ? RD_QUOTE_DECLINED : `${RD_REQUEST} expired`
    const notification = this.notificationClient.createRFPNotification(
      context,
      ReplyType.Declined,
      notifMsg,
      tradeFinanceManager.canReadRDRequests.action,
      senderStaticId,
      emailNotifMsg
    )
    await this.notificationClient.sendNotification(notification)
  }

  private async hasResponseBeenSent(rdId: string) {
    const response = await this.replyDataAgent.findByRdIdAndType(rdId, ReplyType.Submitted)
    return !!response
  }
}
