server_tokens off;

# A value of the "Connection" header field in a request to the proxied server
# depends on the presence of the "Upgrade" field in the client request header
# More here: http://nginx.org/en/docs/http/websocket.html
map $http_upgrade $connection_upgrade {
  default upgrade;
  '' close;
}

server {
  listen 8080 default_server;
  server_name nginx;
  resolver %RESOLVER_ADDR%;

  # API gateway
  location ~ ^/api/([^/]+)/(.*)$ {

    set $custom_request_id $msec$request_id;
    set $target_base_url '';  # will be overwritten later in the Lua script (e.g. http://api-users)
    set $target_path /$2;  # e.g. /v0/profile
    set $target_path_and_query $target_path$is_args$args;  # e.g. /v0/profile?param1=abc
    set $service_name $1;  # users, roles, etc.

    access_by_lua_block {
      local cjson = require "cjson"

      function generateBaseUrl (memberId, port, msName)
        if os.getenv("IS_KUBERNETES_ENV") == "true" then
          return string.format(os.getenv("LMS_API_BASE_URL_TEMPLATE"), msName, memberId)
        else
          return "http://" .. os.getenv("DOCKER_HOST_MACHINE") .. ":" .. (port + (memberId - 1) * 1000)
        end
      end

      function sendErrorResponse (status, message)
        ngx.header.content_type = "application/json; charset=utf-8"
        ngx.status = status
        ngx.say(cjson.encode({ message = message, origin = "lms-router" }))
        ngx.exit(ngx.OK)
      end

      local tenantStaticID = ngx.req.get_headers()["X-Tenant-StaticID"]
      local memberId

      -- we need a default member because not all requests have tenantStaticID (i.e. health, readiness)
      if tenantStaticID == nil then memberId = 3
      elseif tenantStaticID == os.getenv("MEMBER_1_STATIC_ID") then memberId = 1
      elseif tenantStaticID == os.getenv("MEMBER_2_STATIC_ID") then memberId = 2
      else sendErrorResponse(400, "Unknown member with static id '" .. tenantStaticID .. "'. Check env vars")
      end

      local serviceNameToUrl = {
        ["users"] = generateBaseUrl(memberId, 3101, "users"),
        ["notif"] = generateBaseUrl(memberId, 3102, "notif"),
        ["docs"] = generateBaseUrl(memberId, 3106, "docs"),
        ["registry"] = generateBaseUrl(memberId, 3104, "registry"),
        ["coverage"] = generateBaseUrl(memberId, 3110, "coverage"),
        ["signer"] = generateBaseUrl(memberId, 3107, "signer"),
        ["blockchain-signer"] = generateBaseUrl(memberId, 3112, "blockchain-signer")
      }

      if serviceNameToUrl[ngx.var.service_name] == nil then
        sendErrorResponse(404, "Service '" .. ngx.var.service_name .. "' not found")
      end

      ngx.var.target_base_url = serviceNameToUrl[ngx.var.service_name]
    }

    proxy_set_header Host $http_host;
    proxy_set_header X-Request-ID $custom_request_id;
    proxy_pass $target_base_url$target_path_and_query;
    add_header X-Request-ID $custom_request_id always;
  }

  # Proxy singletenant -> multitenant requests
  location ~ ^/multitenant/([-\da-f]+)/([^/]+)/(.*)$ {

    set $custom_request_id $msec$request_id;
    set $target_base_url '';  # will be overwritten later in the Lua script (e.g. http://api-users)
    set $tenant_id $1;  # static id
    set $target_path /$3;  # e.g. /v0/profile
    set $target_path_and_query $target_path$is_args$args;  # e.g. /v0/profile?param1=abc
    set $service_name $2;  # users, roles, etc.

    access_by_lua_block {
      local cjson = require "cjson"

      function sendErrorResponse (status, message)
        ngx.header.content_type = "application/json; charset=utf-8"
        ngx.status = status
        ngx.say(cjson.encode({ message = message, origin = "lms-router" }))
        ngx.exit(ngx.OK)
      end

      local serviceNameToUrl = {
        ["roles"] = os.getenv("API_ROLES_BASE_URL"),
        ["registry"] = os.getenv("API_REGISTRY_BASE_URL"),
        ["auth"] = os.getenv("API_AUTH_BASE_URL")
      }

      if serviceNameToUrl[ngx.var.service_name] == nil then
        sendErrorResponse(404, "Service '" .. ngx.var.service_name .. "' not found")
      end

      ngx.var.target_base_url = serviceNameToUrl[ngx.var.service_name]
    }

    proxy_set_header Host $http_host;
    proxy_set_header X-Request-ID $custom_request_id;
    proxy_set_header X-Tenant-StaticID $tenant_id;
    proxy_pass $target_base_url$target_path_and_query;
    add_header X-Request-ID $custom_request_id always;
  }
}
